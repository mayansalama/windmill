{
    "offset": {
        "x": -1000,
        "y": -1000
    },
    "filename": "Valid",
    "dag": {
        "description": "A dag (directed acyclic graph) is a collection of tasks with directional\ndependencies. A dag also has a schedule, a start date and an end date\n(optional). For each schedule, (say daily or hourly), the DAG needs to run\neach individual tasks as their dependencies are met. Certain tasks have\nthe property of depending on their own past, meaning that they can't run\nuntil their previous schedule (and upstream tasks) are completed.\n\nDAGs essentially act as namespaces for tasks. A task_id can only be\nadded once to a DAG.",
        "name": "ValidDag",
        "parameters": [
            {
                "description": "The id of the DAG",
                "id": "dag_id",
                "inheritedFrom": null,
                "required": true,
                "type": "str",
                "value": "ValidDag"
            },
            {
                "default": "",
                "description": "The description for the DAG to e.g. be shown on the webserver",
                "id": "description",
                "inheritedFrom": null,
                "required": false,
                "type": "str",
                "value": "This is a valid test dag"
            },
            {
                "default": "1 day, 0:00:00",
                "description": "Defines how often that DAG runs, this\ntimedelta object gets added to your latest task instance's\nexecution_date to figure out the next schedule",
                "id": "schedule_interval",
                "inheritedFrom": null,
                "required": false,
                "type": "datetime.timedelta",
                "value": "1 day, 0:00:00"
            },
            {
                "default": null,
                "description": "The timestamp from which the scheduler will\nattempt to backfill",
                "id": "start_date",
                "inheritedFrom": null,
                "required": false,
                "type": "datetime.datetime",
                "value": "2020/05/20"
            },
            {
                "default": null,
                "description": "A date beyond which your DAG won't run, leave to None\nfor open ended scheduling",
                "id": "end_date",
                "inheritedFrom": null,
                "required": false,
                "type": "datetime.datetime"
            },
            {
                "default": null,
                "description": "This list of folders (non relative)\ndefines where jinja will look for your templates. Order matters.\nNote that jinja/airflow includes the path of your DAG file by\ndefault",
                "id": "template_searchpath",
                "inheritedFrom": null,
                "required": false,
                "type": "str"
            },
            {
                "default": "<class 'jinja2.runtime.Undefined'>",
                "description": "Template undefined type.",
                "id": "template_undefined",
                "inheritedFrom": null,
                "required": false,
                "type": "str",
                "value": "<class 'jinja2.runtime.Undefined'>"
            },
            {
                "default": null,
                "description": "a dictionary of macros that will be exposed\nin your jinja templates. For example, passing ``dict(foo='bar')``\nto this argument allows you to ``{{ foo }}`` in all jinja\ntemplates related to this DAG. Note that you can pass any\ntype of object here.",
                "id": "user_defined_macros",
                "inheritedFrom": null,
                "required": false,
                "type": "dict"
            },
            {
                "default": null,
                "description": "a dictionary of filters that will be exposed\nin your jinja templates. For example, passing\n``dict(hello=lambda name: 'Hello %s' % name)`` to this argument allows\nyou to ``{{ 'world' | hello }}`` in all jinja templates related to\nthis DAG.",
                "id": "user_defined_filters",
                "inheritedFrom": null,
                "required": false,
                "type": "dict"
            },
            {
                "default": null,
                "description": "A dictionary of default parameters to be used\nas constructor keyword parameters when initialising operators.\nNote that operators have the same hook, and precede those defined\nhere, meaning that if your dict contains `'depends_on_past': True`\nhere and `'depends_on_past': False` in the operator's call\n`default_args`, the actual value will be `False`.",
                "id": "default_args",
                "inheritedFrom": null,
                "required": false,
                "type": "dict"
            },
            {
                "default": null,
                "description": "a dictionary of DAG level parameters that are made\naccessible in templates, namespaced under `params`. These\nparams can be overridden at the task level.",
                "id": "params",
                "inheritedFrom": null,
                "required": false,
                "type": "dict"
            },
            {
                "default": "16",
                "description": "the number of task instances allowed to run\nconcurrently",
                "id": "concurrency",
                "inheritedFrom": null,
                "required": false,
                "type": "int",
                "value": "16"
            },
            {
                "default": "16",
                "description": "maximum number of active DAG runs, beyond this\nnumber of DAG runs in a running state, the scheduler won't create\nnew active DAG runs",
                "id": "max_active_runs",
                "inheritedFrom": null,
                "required": false,
                "type": "int",
                "value": "16"
            },
            {
                "default": null,
                "description": "specify how long a DagRun should be up before\ntiming out / failing, so that new DagRuns can be created. The timeout\nis only enforced for scheduled DagRuns, and only once the\n# of active DagRuns == max_active_runs.",
                "id": "dagrun_timeout",
                "inheritedFrom": null,
                "required": false,
                "type": "datetime.timedelta"
            },
            {
                "default": null,
                "description": "specify a function to call when reporting SLA\ntimeouts.",
                "id": "sla_miss_callback",
                "inheritedFrom": null,
                "required": false,
                "type": "str"
            },
            {
                "default": null,
                "description": "Specify DAG default view (tree, graph, duration,\ngantt, landing_times)",
                "id": "default_view",
                "inheritedFrom": null,
                "required": false,
                "type": "str"
            },
            {
                "default": "LR",
                "description": "Specify DAG orientation in graph view (LR, TB, RL, BT)",
                "id": "orientation",
                "inheritedFrom": null,
                "required": false,
                "type": "str",
                "value": "LR"
            },
            {
                "default": "True",
                "description": "Perform scheduler catchup (or only run latest)? Defaults to True",
                "id": "catchup",
                "inheritedFrom": null,
                "required": false,
                "type": "bool",
                "value": "True"
            },
            {
                "default": null,
                "description": "A function to be called when a DagRun of this dag fails.\nA context dictionary is passed as a single parameter to this function.",
                "id": "on_failure_callback",
                "inheritedFrom": null,
                "required": false,
                "type": "callable"
            },
            {
                "default": null,
                "description": "Much like the ``on_failure_callback`` except\nthat it is executed when the dag succeeds.",
                "id": "on_success_callback",
                "inheritedFrom": null,
                "required": false,
                "type": "callable"
            },
            {
                "default": null,
                "description": "Specify optional DAG-level permissions, e.g.,\n\"{'role1': {'can_dag_read'}, 'role2': {'can_dag_read', 'can_dag_edit'}}\"",
                "id": "access_control",
                "inheritedFrom": null,
                "required": false,
                "type": "dict"
            },
            {
                "default": null,
                "description": "Specifies if the dag is paused when created for the first time.\nIf the dag exists already, this flag will be ignored. If this optional parameter\nis not specified, the global config setting will be used.",
                "id": "is_paused_upon_creation",
                "inheritedFrom": null,
                "required": false,
                "type": "bool"
            }
        ]
    },
    "nodes": {
        "67188218-7988-45b2-9cdf-a95897f40eb4": {
            "id": "67188218-7988-45b2-9cdf-a95897f40eb4",
            "orientation": 0,
            "ports": {
                "in_port": {
                    "id": "in_port",
                    "position": {
                        "x": 100,
                        "y": 0
                    },
                    "properties": {
                        "value": "in"
                    },
                    "type": "top"
                },
                "out_port": {
                    "id": "out_port",
                    "position": {
                        "x": 100,
                        "y": 80
                    },
                    "properties": {
                        "value": "out"
                    },
                    "type": "bottom"
                }
            },
            "position": {
                "x": 1180.9999694824219,
                "y": 1130.7465209960938
            },
            "properties": {
                "description": "Execute a Bash script, command or set of commands.\n.. seealso::\n    For more information on how to use this operator, take a look at the guide:\n    :ref:`howto/operator:BashOperator`",
                "module": "airflow.operators.bash_operator",
                "name": "Task1",
                "parameters": [
                    {
                        "description": "The command, set of commands or reference to a\nbash script (must be '.sh') to be executed. (templated)",
                        "id": "bash_command",
                        "inheritedFrom": null,
                        "required": true,
                        "type": "str",
                        "value": "echo 1"
                    },
                    {
                        "default": "False",
                        "description": "If xcom_push is True, the last line written to stdout\nwill also be pushed to an XCom when the bash command completes.",
                        "id": "xcom_push",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": null,
                        "description": "If env is not None, it must be a mapping that defines the\nenvironment variables for the new process; these are used instead\nof inheriting the current process environment, which is the default\nbehavior. (templated)",
                        "id": "env",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": "utf-8",
                        "description": "Output encoding of bash command",
                        "id": "output_encoding",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "str",
                        "value": "utf-8"
                    },
                    {
                        "description": "a unique, meaningful id for the task",
                        "id": "task_id",
                        "inheritedFrom": "BaseOperator",
                        "required": true,
                        "type": "str",
                        "value": "Task1"
                    },
                    {
                        "default": "airflow",
                        "description": "the owner of the task, using the unix username is recommended",
                        "id": "owner",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "airflow"
                    },
                    {
                        "default": "0",
                        "description": "the number of retries that should be performed before\nfailing the task",
                        "id": "retries",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int",
                        "value": "0"
                    },
                    {
                        "default": "0:05:00",
                        "description": "delay between retries",
                        "id": "retry_delay",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta",
                        "value": "0:05:00"
                    },
                    {
                        "default": "False",
                        "description": "allow progressive longer waits between\nretries by using exponential backoff algorithm on retry delay (delay\nwill be converted into seconds)",
                        "id": "retry_exponential_backoff",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": null,
                        "description": "maximum delay interval between retries",
                        "id": "max_retry_delay",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "The ``start_date`` for the task, determines\nthe ``execution_date`` for the first task instance. The best practice\nis to have the start_date rounded\nto your DAG's ``schedule_interval``. Daily jobs have their start_date\nsome day at 00:00:00, hourly jobs have their start_date at 00:00\nof a specific hour. Note that Airflow simply looks at the latest\n``execution_date`` and adds the ``schedule_interval`` to determine\nthe next ``execution_date``. It is also very important\nto note that different tasks' dependencies\nneed to line up in time. If task A depends on task B and their\nstart_date are offset in a way that their execution_date don't line\nup, A's dependencies will never be met. If you are looking to delay\na task, for example running a daily task at 2AM, look into the\n``TimeSensor`` and ``TimeDeltaSensor``. We advise against using\ndynamic ``start_date`` and recommend using fixed ones. Read the\nFAQ entry about start_date for more information.",
                        "id": "start_date",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.datetime"
                    },
                    {
                        "default": null,
                        "description": "if specified, the scheduler won't go beyond this date",
                        "id": "end_date",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.datetime"
                    },
                    {
                        "default": "False",
                        "description": "when set to true, task instances will run\nsequentially while relying on the previous task's schedule to\nsucceed. The task instance for the start_date is allowed to run.",
                        "id": "depends_on_past",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": "False",
                        "description": "when set to true, an instance of task\nX will wait for tasks immediately downstream of the previous instance\nof task X to finish successfully before it runs. This is useful if the\ndifferent instances of a task X alter the same asset, and this asset\nis used by tasks downstream of task X. Note that depends_on_past\nis forced to True wherever wait_for_downstream is used.",
                        "id": "wait_for_downstream",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": "default",
                        "description": "which queue to target when running this job. Not\nall executors implement queue management, the CeleryExecutor\ndoes support targeting specific queues.",
                        "id": "queue",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "default"
                    },
                    {
                        "default": null,
                        "description": "a reference to the dag the task is attached to (if any)",
                        "id": "dag",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str"
                    },
                    {
                        "default": "1",
                        "description": "priority weight of this task against other task.\nThis allows the executor to trigger higher priority tasks before\nothers when things get backed up. Set priority_weight as a higher\nnumber for more important tasks.",
                        "id": "priority_weight",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int",
                        "value": "1"
                    },
                    {
                        "default": "downstream",
                        "description": "weighting method used for the effective total\npriority weight of the task. Options are:\n``{ downstream | upstream | absolute }`` default is ``downstream``\nWhen set to ``downstream`` the effective weight of the task is the\naggregate sum of all downstream descendants. As a result, upstream\ntasks will have higher weight and will be scheduled more aggressively\nwhen using positive weight values. This is useful when you have\nmultiple dag run instances and desire to have all upstream tasks to\ncomplete for all runs before each dag can continue processing\ndownstream tasks. When set to ``upstream`` the effective weight is the\naggregate sum of all upstream ancestors. This is the opposite where\ndowntream tasks have higher weight and will be scheduled more\naggressively when using positive weight values. This is useful when you\nhave multiple dag run instances and prefer to have each dag complete\nbefore starting upstream tasks of other dags.  When set to\n``absolute``, the effective weight is the exact ``priority_weight``\nspecified without additional weighting. You may want to do this when\nyou know exactly what priority weight each task should have.\nAdditionally, when set to ``absolute``, there is bonus effect of\nsignificantly speeding up the task creation process as for very large\nDAGS. Options can be set as string or using the constants defined in\nthe static class ``airflow.utils.WeightRule``",
                        "id": "weight_rule",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "downstream"
                    },
                    {
                        "default": "default_pool",
                        "description": "the slot pool this task should run in, slot pools are a\nway to limit concurrency for certain tasks",
                        "id": "pool",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "default_pool"
                    },
                    {
                        "default": null,
                        "description": "time by which the job is expected to succeed. Note that\nthis represents the ``timedelta`` after the period is closed. For\nexample if you set an SLA of 1 hour, the scheduler would send an email\nsoon after 1:00AM on the ``2016-01-02`` if the ``2016-01-01`` instance\nhas not succeeded yet.\nThe scheduler pays special attention for jobs with an SLA and\nsends alert\nemails for sla misses. SLA misses are also recorded in the database\nfor future reference. All tasks that share the same SLA time\nget bundled in a single email, sent soon after that time. SLA\nnotification are sent once and only once for each task instance.",
                        "id": "sla",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "max time allowed for the execution of\nthis task instance, if it goes beyond it will raise and fail.",
                        "id": "execution_timeout",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "a function to be called when a task instance\nof this task fails. a context dictionary is passed as a single\nparameter to this function. Context contains references to related\nobjects to the task instance and is documented under the macros\nsection of the API.",
                        "id": "on_failure_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": null,
                        "description": "much like the ``on_failure_callback`` except\nthat it is executed when retries occur.",
                        "id": "on_retry_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": null,
                        "description": "much like the ``on_failure_callback`` except\nthat it is executed when the task succeeds.",
                        "id": "on_success_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": "all_success",
                        "description": "defines the rule by which dependencies are applied\nfor the task to get triggered. Options are:\n``{ all_success | all_failed | all_done | one_success |\none_failed | none_failed | none_skipped | dummy}``\ndefault is ``all_success``. Options can be set as string or\nusing the constants defined in the static class\n``airflow.utils.TriggerRule``",
                        "id": "trigger_rule",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "all_success"
                    },
                    {
                        "default": null,
                        "description": "A map of resource parameter names (the argument names of the\nResources constructor) to their values.",
                        "id": "resources",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": null,
                        "description": "unix username to impersonate while running the task",
                        "id": "run_as_user",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str"
                    },
                    {
                        "default": null,
                        "description": "When set, a task will be able to limit the concurrent\nruns across execution_dates",
                        "id": "task_concurrency",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int"
                    },
                    {
                        "default": null,
                        "description": "Additional task-level configuration parameters that are\ninterpreted by a specific executor. Parameters are namespaced by the name of\nexecutor.\n\n**Example**: to run this task in a specific docker container through\nthe KubernetesExecutor ::\n\n    MyOperator(...,\n        executor_config={\n        \"KubernetesExecutor\":\n            {\"image\": \"myCustomDockerImage\"}\n            }\n    )",
                        "id": "executor_config",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": "True",
                        "description": "if True, an XCom is pushed containing the Operator's\nresult",
                        "id": "do_xcom_push",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "True"
                    }
                ]
            },
            "size": {
                "width": 200,
                "height": 80
            },
            "type": "BashOperator"
        },
        "fc51a6c3-c8f1-4cd6-8a5d-65ff6c0aa460": {
            "id": "fc51a6c3-c8f1-4cd6-8a5d-65ff6c0aa460",
            "position": {
                "x": 1193.9999694824219,
                "y": 1346.7465209960938
            },
            "orientation": 0,
            "type": "BashOperator",
            "ports": {
                "in_port": {
                    "id": "in_port",
                    "type": "top",
                    "properties": {
                        "value": "in"
                    },
                    "position": {
                        "x": 100,
                        "y": 0
                    }
                },
                "out_port": {
                    "id": "out_port",
                    "type": "bottom",
                    "properties": {
                        "value": "out"
                    },
                    "position": {
                        "x": 100,
                        "y": 80
                    }
                }
            },
            "properties": {
                "description": "Execute a Bash script, command or set of commands.\n.. seealso::\n    For more information on how to use this operator, take a look at the guide:\n    :ref:`howto/operator:BashOperator`",
                "module": "airflow.operators.bash_operator",
                "parameters": [
                    {
                        "description": "The command, set of commands or reference to a\nbash script (must be '.sh') to be executed. (templated)",
                        "id": "bash_command",
                        "inheritedFrom": null,
                        "required": true,
                        "type": "str",
                        "value": "echo \"2\""
                    },
                    {
                        "default": "False",
                        "description": "If xcom_push is True, the last line written to stdout\nwill also be pushed to an XCom when the bash command completes.",
                        "id": "xcom_push",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": null,
                        "description": "If env is not None, it must be a mapping that defines the\nenvironment variables for the new process; these are used instead\nof inheriting the current process environment, which is the default\nbehavior. (templated)",
                        "id": "env",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": "utf-8",
                        "description": "Output encoding of bash command",
                        "id": "output_encoding",
                        "inheritedFrom": null,
                        "required": false,
                        "type": "str",
                        "value": "utf-8"
                    },
                    {
                        "description": "a unique, meaningful id for the task",
                        "id": "task_id",
                        "inheritedFrom": "BaseOperator",
                        "required": true,
                        "type": "str",
                        "value": "Task2"
                    },
                    {
                        "default": "airflow",
                        "description": "the owner of the task, using the unix username is recommended",
                        "id": "owner",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "airflow"
                    },
                    {
                        "default": "0",
                        "description": "the number of retries that should be performed before\nfailing the task",
                        "id": "retries",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int",
                        "value": "0"
                    },
                    {
                        "default": "0:05:00",
                        "description": "delay between retries",
                        "id": "retry_delay",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta",
                        "value": "0:05:00"
                    },
                    {
                        "default": "False",
                        "description": "allow progressive longer waits between\nretries by using exponential backoff algorithm on retry delay (delay\nwill be converted into seconds)",
                        "id": "retry_exponential_backoff",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": null,
                        "description": "maximum delay interval between retries",
                        "id": "max_retry_delay",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "The ``start_date`` for the task, determines\nthe ``execution_date`` for the first task instance. The best practice\nis to have the start_date rounded\nto your DAG's ``schedule_interval``. Daily jobs have their start_date\nsome day at 00:00:00, hourly jobs have their start_date at 00:00\nof a specific hour. Note that Airflow simply looks at the latest\n``execution_date`` and adds the ``schedule_interval`` to determine\nthe next ``execution_date``. It is also very important\nto note that different tasks' dependencies\nneed to line up in time. If task A depends on task B and their\nstart_date are offset in a way that their execution_date don't line\nup, A's dependencies will never be met. If you are looking to delay\na task, for example running a daily task at 2AM, look into the\n``TimeSensor`` and ``TimeDeltaSensor``. We advise against using\ndynamic ``start_date`` and recommend using fixed ones. Read the\nFAQ entry about start_date for more information.",
                        "id": "start_date",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.datetime"
                    },
                    {
                        "default": null,
                        "description": "if specified, the scheduler won't go beyond this date",
                        "id": "end_date",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.datetime"
                    },
                    {
                        "default": "False",
                        "description": "when set to true, task instances will run\nsequentially while relying on the previous task's schedule to\nsucceed. The task instance for the start_date is allowed to run.",
                        "id": "depends_on_past",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": "False",
                        "description": "when set to true, an instance of task\nX will wait for tasks immediately downstream of the previous instance\nof task X to finish successfully before it runs. This is useful if the\ndifferent instances of a task X alter the same asset, and this asset\nis used by tasks downstream of task X. Note that depends_on_past\nis forced to True wherever wait_for_downstream is used.",
                        "id": "wait_for_downstream",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "False"
                    },
                    {
                        "default": "default",
                        "description": "which queue to target when running this job. Not\nall executors implement queue management, the CeleryExecutor\ndoes support targeting specific queues.",
                        "id": "queue",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "default"
                    },
                    {
                        "default": null,
                        "description": "a reference to the dag the task is attached to (if any)",
                        "id": "dag",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str"
                    },
                    {
                        "default": "1",
                        "description": "priority weight of this task against other task.\nThis allows the executor to trigger higher priority tasks before\nothers when things get backed up. Set priority_weight as a higher\nnumber for more important tasks.",
                        "id": "priority_weight",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int",
                        "value": "1"
                    },
                    {
                        "default": "downstream",
                        "description": "weighting method used for the effective total\npriority weight of the task. Options are:\n``{ downstream | upstream | absolute }`` default is ``downstream``\nWhen set to ``downstream`` the effective weight of the task is the\naggregate sum of all downstream descendants. As a result, upstream\ntasks will have higher weight and will be scheduled more aggressively\nwhen using positive weight values. This is useful when you have\nmultiple dag run instances and desire to have all upstream tasks to\ncomplete for all runs before each dag can continue processing\ndownstream tasks. When set to ``upstream`` the effective weight is the\naggregate sum of all upstream ancestors. This is the opposite where\ndowntream tasks have higher weight and will be scheduled more\naggressively when using positive weight values. This is useful when you\nhave multiple dag run instances and prefer to have each dag complete\nbefore starting upstream tasks of other dags.  When set to\n``absolute``, the effective weight is the exact ``priority_weight``\nspecified without additional weighting. You may want to do this when\nyou know exactly what priority weight each task should have.\nAdditionally, when set to ``absolute``, there is bonus effect of\nsignificantly speeding up the task creation process as for very large\nDAGS. Options can be set as string or using the constants defined in\nthe static class ``airflow.utils.WeightRule``",
                        "id": "weight_rule",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "downstream"
                    },
                    {
                        "default": "default_pool",
                        "description": "the slot pool this task should run in, slot pools are a\nway to limit concurrency for certain tasks",
                        "id": "pool",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "default_pool"
                    },
                    {
                        "default": null,
                        "description": "time by which the job is expected to succeed. Note that\nthis represents the ``timedelta`` after the period is closed. For\nexample if you set an SLA of 1 hour, the scheduler would send an email\nsoon after 1:00AM on the ``2016-01-02`` if the ``2016-01-01`` instance\nhas not succeeded yet.\nThe scheduler pays special attention for jobs with an SLA and\nsends alert\nemails for sla misses. SLA misses are also recorded in the database\nfor future reference. All tasks that share the same SLA time\nget bundled in a single email, sent soon after that time. SLA\nnotification are sent once and only once for each task instance.",
                        "id": "sla",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "max time allowed for the execution of\nthis task instance, if it goes beyond it will raise and fail.",
                        "id": "execution_timeout",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "datetime.timedelta"
                    },
                    {
                        "default": null,
                        "description": "a function to be called when a task instance\nof this task fails. a context dictionary is passed as a single\nparameter to this function. Context contains references to related\nobjects to the task instance and is documented under the macros\nsection of the API.",
                        "id": "on_failure_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": null,
                        "description": "much like the ``on_failure_callback`` except\nthat it is executed when retries occur.",
                        "id": "on_retry_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": null,
                        "description": "much like the ``on_failure_callback`` except\nthat it is executed when the task succeeds.",
                        "id": "on_success_callback",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "callable"
                    },
                    {
                        "default": "all_success",
                        "description": "defines the rule by which dependencies are applied\nfor the task to get triggered. Options are:\n``{ all_success | all_failed | all_done | one_success |\none_failed | none_failed | none_skipped | dummy}``\ndefault is ``all_success``. Options can be set as string or\nusing the constants defined in the static class\n``airflow.utils.TriggerRule``",
                        "id": "trigger_rule",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str",
                        "value": "all_success"
                    },
                    {
                        "default": null,
                        "description": "A map of resource parameter names (the argument names of the\nResources constructor) to their values.",
                        "id": "resources",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": null,
                        "description": "unix username to impersonate while running the task",
                        "id": "run_as_user",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "str"
                    },
                    {
                        "default": null,
                        "description": "When set, a task will be able to limit the concurrent\nruns across execution_dates",
                        "id": "task_concurrency",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "int"
                    },
                    {
                        "default": null,
                        "description": "Additional task-level configuration parameters that are\ninterpreted by a specific executor. Parameters are namespaced by the name of\nexecutor.\n\n**Example**: to run this task in a specific docker container through\nthe KubernetesExecutor ::\n\n    MyOperator(...,\n        executor_config={\n        \"KubernetesExecutor\":\n            {\"image\": \"myCustomDockerImage\"}\n            }\n    )",
                        "id": "executor_config",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "dict"
                    },
                    {
                        "default": "True",
                        "description": "if True, an XCom is pushed containing the Operator's\nresult",
                        "id": "do_xcom_push",
                        "inheritedFrom": "BaseOperator",
                        "required": false,
                        "type": "bool",
                        "value": "True"
                    }
                ],
                "name": "Task2"
            },
            "size": {
                "width": 200,
                "height": 80
            }
        }
    },
    "links": {
        "6130c106-3498-4b74-9577-a2c9732b314b": {
            "id": "6130c106-3498-4b74-9577-a2c9732b314b",
            "from": {
                "nodeId": "67188218-7988-45b2-9cdf-a95897f40eb4",
                "portId": "out_port"
            },
            "to": {
                "nodeId": "fc51a6c3-c8f1-4cd6-8a5d-65ff6c0aa460",
                "portId": "in_port"
            }
        }
    }
}